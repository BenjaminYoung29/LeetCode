﻿## 题目https://leetcode.com/problems/add-two-numbers/```You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)Output: 7 -> 0 -> 8Explanation: 342 + 465 = 807.```## 思路题意为两个数字倒序，用单向链表表示，然后相加，结果也是用单向链表表示。342倒序为2->4->3。在纸上试一下发现其实只是普通加法，只不过进位进到左边而不是右边。需要考虑的情况有以下几种：- 两个链表一样长  - 相加最后没有进位，如3+4  - 相加最后进位了，如5+5- 两个链表不一样长 - 相加最后没有进位，如1+8->9 - 相加最后进位了，如 1+ 9->9->9## 关键点容易没有考虑情况中的一样长最后进位和不一样长最后进位## 代码# 我的代码`        class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        boolean flag=false;        ListNode l3=new ListNode(0);        ListNode head = l3;        int x=0;        while(l1!=null&l2!=null){            int sum = l1.val+l2.val;                        if(flag)                sum += 1;                        x = sum;            if(sum>=10){                x -= 10;                flag=true;            }else{                flag=false;            }            ListNode l=new ListNode(x);            l3.next=l;            l3=l;            l1=l1.next;            l2=l2.next;        }        ListNode tmp=null;        if(l1!=null)            tmp=l1;        else if(l2!=null)            tmp=l2;        while(tmp!=null){            if(flag){                tmp.val+=1;                                if(tmp.val>=10){                    tmp.val-=10;                    flag=true;                }else                    flag=false;            }            l3.next=tmp;            l3=l3.next;            tmp=tmp.next;                        }                        if(flag){            ListNode l=new ListNode(1);            l3.next=l;        }        return head.next;    }    }`# 精简后‘    class Solution{        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {            int sum=0;             boolean flag=false; //是否产生进位            ListNode l3=new ListNode(0); //一个占位的节点            ListNode head=l3;  #记录链表头            while(l1!=null || l2!=null || sum!=0 || flag){                  if(l1!=null){                      sum+=l1.val;                         l1=l1.next;                               }                    if(l2!=null){                      sum+=l2.val;                      l2=l2.next;                  }                  if(flag)                      sum+=1;                  if(sum>=10){                      flag=true;                      sum-=10;                  }                  else                      flag=false;                  ListNode l=new ListNode(sum);                  l3.next=l;                  l3=l3.next;                  sum=0;            }            return head.next;        }    }’